schema {
  query: Query
}

# NOTE(PN): All date fields are ints in seconds from epoch

# The query type, represents all of the entry points into our object graph
type Query {
  # TCR / Crawler Queries (Legacy naming)
  # TODO(PN): Temporary keep these until migrated over to new naming
  # Just calls the properly named versions
  articles(
    addr: String
    first: Int
    after: String
    contentID: Int
    revisionID: Int
    lowercaseAddr: Boolean = True
  ): [ContentRevision!]!
  challenge(id: Int!, lowercaseAddr: Boolean = True): Challenge
  governanceEvents(
    addr: String
    after: String
    creationDate: DateRange
    first: Int
    lowercaseAddr: Boolean = True
  ): [GovernanceEvent!]!
  governanceEventsTxHash(
    txHash: String!
    lowercaseAddr: Boolean = True
  ): [GovernanceEvent!]!
  listing(addr: String!, lowercaseAddr: Boolean = True): Listing
  listings(
    first: Int
    after: String
    whitelistedOnly: Boolean
    rejectedOnly: Boolean
    activeChallenge: Boolean
    currentApplication: Boolean
    lowercaseAddr: Boolean = True
    sortBy: ListingSort
    sortDesc: Boolean = False
  ): [Listing!]!

  # TCR Queries
  tcrChallenge(id: Int!, lowercaseAddr: Boolean = True): Challenge
  tcrGovernanceEvents(
    addr: String
    after: String
    creationDate: DateRange
    first: Int
    lowercaseAddr: Boolean = True
  ): GovernanceEventResultCursor
  tcrGovernanceEventsTxHash(
    txHash: String!
    lowercaseAddr: Boolean = True
  ): [GovernanceEvent!]!
  tcrListing(addr: String!, lowercaseAddr: Boolean = True): Listing
  tcrListings(
    first: Int
    after: String
    whitelistedOnly: Boolean
    rejectedOnly: Boolean
    activeChallenge: Boolean
    currentApplication: Boolean
    lowercaseAddr: Boolean = True
    sortBy: ListingSort
    sortDesc: Boolean = False
  ): ListingResultCursor

  # Channel Queries
  channelsGetByID(id: String!): Channel
  channelsGetByNewsroomAddress(contractAddress: String!): Channel
  channelsGetByHandle(handle: String!): Channel
  channelsGetByUserID(userID: String!): Channel

  # Newsroom Queries
  newsroomArticles(
    addr: String
    first: Int
    after: String
    contentID: Int
    revisionID: Int
    lowercaseAddr: Boolean = True
  ): [ContentRevision!]!
  nrsignupNewsroom: NrsignupNewsroom

  # Post Queries
  postsGet(id: String!): Post!
  postsSearch(search: PostSearchInput!): PostSearchResult

  # UserChallengeData Queries
  userChallengeData(
    userAddr: String
    pollID: Int
    canUserCollect: Boolean
    canUserRescue: Boolean
    canUserReveal: Boolean
  ): [UserChallengeVoteData!]!

  # User Queries
  currentUser: User

  # Storefront
  storefrontEthPrice: Float
  storefrontCvlPrice: Float
  storefrontCvlQuoteUsd(usdToSpend: Float!): Float
  storefrontCvlQuoteTokens(tokensToBuy: Float!): Float

  # JSONb Store Query
  jsonb(id: String): Jsonb
}

type Mutation {
  # Auth Mutations
  authSignupEth(input: UserSignatureInput!): AuthLoginResponse
  authSignupEmailSend(
    emailAddress: String!
    addToMailing: Boolean = False
  ): String
  authSignupEmailSendForApplication(
    emailAddress: String!
    application: AuthApplicationEnum!
    addToMailing: Boolean = False
  ): String
  authSignupEmailConfirm(signupJWT: String!): AuthLoginResponse
  authLoginEth(input: UserSignatureInput!): AuthLoginResponse
  authLoginEmailSend(
    emailAddress: String!
    addToMailing: Boolean = False
  ): String
  authLoginEmailSendForApplication(
    emailAddress: String!
    application: AuthApplicationEnum!
    addToMailing: Boolean = False
  ): String
  authLoginEmailConfirm(loginJWT: String!): AuthLoginResponse
  authRefresh(token: String!): AuthLoginResponse

  # JSONb Store Mutations
  jsonbSave(input: JsonbInput!): Jsonb!

  # Channels Mutations
  channelsCreateNewsroomChannel(newsroomContractAddress: String!): Channel
  channelsConnectStripe(input: ChannelsConnectStripeInput!): Channel
  channelsSetHandle(input: ChannelsSetHandleInput!): Channel
  channelsSetEmail(input: ChannelsSetEmailInput!): Channel
  channelsSetEmailConfirm(jwt: String!): ChannelSetEmailResponse

  # Newsroom Signup Mutations
  nrsignupSendWelcomeEmail: String!
  nrsignupSaveCharter(charterData: CharterInput!): String!
  nrsignupRequestGrant(requested: Boolean!): String!
  nrsignupApproveGrant(approved: Boolean!, newsroomOwnerUID: String!): String!
  nrsignupSaveTxHash(txHash: String!): String!
  nrsignupSaveAddress(address: String!): String!
  nrsignupSaveNewsroomApplyTxHash(txHash: String!): String!
  nrsignupPollNewsroomDeploy(txHash: String!): String!
  nrsignupPollTcrApplication(txHash: String!): String!
  nrsignupUpdateSteps(input: NrsignupStepsInput!): String!

  # Payment Mutations
  paymentsCreateStripePayment(
    postID: String!
    input: PaymentsCreateStripePaymentInput!
  ): PaymentStripe!
  paymentsCreateEtherPayment(
    postID: String!
    input: PaymentsCreateEtherPaymentInput!
  ): PaymentEther!
  paymentsCreateTokenPayment(
    postID: String!
    input: PaymentsCreateTokenPaymentInput!
  ): PaymentToken!

  # Post Mutations
  postsCreateBoost(input: PostCreateBoostInput!): PostBoost
  postsUpdateBoost(postID: String!, input: PostCreateBoostInput!): PostBoost

  postsCreateExternalLink(input: PostCreateExternalLinkInput!): PostExternalLink
  postsUpdateExternalLink(
    postID: String!
    input: PostCreateExternalLinkInput!
  ): PostExternalLink

  postsCreateComment(input: PostCreateCommentInput!): PostComment
  postsUpdateComment(
    postID: String!
    input: PostCreateCommentInput!
  ): PostComment

  # Storefront Mutations
  storefrontAirswapTxHash(txHash: String!): String!
  storefrontAirswapCancelled: String!

  # Listing Mutations
  tcrListingSaveTopicID(addr: String!, topicID: Int!): String!

  # User Mutations
  userSetEthAddress(input: UserSignatureInput!): String
  userUpdate(uid: String, input: UserUpdateInput): User
}

# Enum of valid values for application types for auth
enum AuthApplicationEnum {
  DEFAULT
  NEWSROOM
  STOREFRONT
}

## Auth object schemas
type AuthLoginResponse {
  token: String
  refreshToken: String
  uid: String
}

type ChannelSetEmailResponse {
  ChannelID: String
  UserID: String
}

## TCR object schemas

# A type that reflects values in model.Appeal
type Appeal {
  requester: String!
  appealFeePaid: String!
  appealPhaseExpiry: Int!
  appealGranted: Boolean!
  appealOpenToChallengeExpiry: Int!
  statement: String!
  appealChallengeID: Int!
  appealChallenge: Challenge
  appealGrantedStatementURI: String!
}

# A type that reflects block data in model.BlockData
type BlockData {
  blockNumber: Int!
  txHash: String!
  txIndex: Int!
  blockHash: String!
  index: Int!
}

# A type that reflects values in model.Challenge
type Challenge {
  challengeID: Int!
  listingAddress: String!
  statement: String!
  rewardPool: String!
  challenger: String!
  resolved: Boolean!
  stake: String!
  totalTokens: String!
  poll: Poll
  requestAppealExpiry: Int!
  appeal: Appeal
  lastUpdatedDateTs: Int!
}

# A type that represents a Charter
type Charter {
  uri: String!
  contentID: Int!
  revisionID: Int!
  signature: String!
  author: String!
  contentHash: String!
  timestamp: Int!
}

# A type that reflects values in model.GovernanceEvent
type GovernanceEvent {
  listingAddress: String!
  metadata: [Metadata!]!
  governanceEventType: String!
  creationDate: Int!
  lastUpdatedDate: Int!
  eventHash: String!
  blockData: BlockData!
  listing: Listing!
}

# A type that represents an edge value in a GovernanceEvent
type GovernanceEventEdge {
  cursor: String!
  node: GovernanceEvent!
}

# A type that represents return values from GovernanceEvents
type GovernanceEventResultCursor {
  edges: [GovernanceEventEdge]!
  pageInfo: PageInfo!
}

# A type that reflects values in model.Listing
type Listing {
  name: String!
  contractAddress: String!
  whitelisted: Boolean!
  lastGovState: String!
  url: String!
  charter: Charter
  ownerAddresses: [String!]!
  owner: String!
  contributorAddresses: [String!]!
  createdDate: Int!
  applicationDate: Int
  approvalDate: Int
  lastUpdatedDate: Int!
  appExpiry: Int!
  unstakedDeposit: String!
  challengeID: Int!
  discourseTopicID: Int
  challenge: Challenge
  prevChallenge: Challenge
}

# A type that represents a edge value in a Listing
type ListingEdge {
  cursor: String!
  node: Listing!
}

# A type that represents return values from Listings
type ListingResultCursor {
  edges: [ListingEdge]!
  pageInfo: PageInfo!
}

# Enum of valid sort values for Listings
enum ListingSort {
  DEFAULT
  NAME
  CREATED
  APPLIED
  WHITELISTED
}

# A type that reflects values in model.Metadata
type Metadata {
  key: String!
  value: String!
}

# A type that reflects values in model.Poll
type Poll {
  commitEndDate: Int!
  revealEndDate: Int!
  voteQuorum: Int!
  votesFor: String!
  votesAgainst: String!
}

# A type that reflects values in model.UserChallengeData
type UserChallengeVoteData {
  pollID: Int!
  pollRevealDate: Int!
  pollType: String!
  userAddress: String!
  userDidCommit: Boolean!
  userDidReveal: Boolean!
  didUserCollect: Boolean!
  didUserRescue: Boolean!
  didCollectAmount: String!
  isVoterWinner: Boolean!
  pollIsPassed: Boolean!
  salt: Int!
  choice: Int!
  numTokens: String!
  voterReward: String!
  parentChallengeID: Int!
}

## Newsroom object schemas

# A type that reflects values in model.ArticlePayload
type ArticlePayload {
  key: String!
  value: ArticlePayloadValue!
}

# A type that reflects values in model.ContentRevision
type ContentRevision {
  listingAddress: String!
  payload: [ArticlePayload!]!
  payloadHash: String!
  editorAddress: String!
  contractContentId: Int!
  contractRevisionId: Int!
  revisionUri: String!
  revisionDate: Int!
}

## Channel object schemas

type Channel {
  id: String!
  channelType: String!
  newsroom: Newsroom
  postsSearch(search: PostSearchInput!): PostSearchResult
  isStripeConnected: Boolean!
  currentUserIsAdmin: Boolean!
  handle: String
  EmailAddressRestricted: String
}

type ChannelMember {
  channel: Channel
  role: String
}

input ChannelsConnectStripeInput {
  channelID: String!
  oauthCode: String!
}

input ChannelsSetHandleInput {
  channelID: String!
  handle: String!
}

input ChannelsSetEmailInput {
  channelID: String!
  emailAddress: String!
}

## Post object schemas
# post types
interface Post {
  id: String!
  channelID: String!
  parentID: String
  authorID: String!
  createdAt: Time!
  updatedAt: Time!
  children: [Post]
  payments: [Payment!]
  paymentsTotal(currencyCode: String!): Float!
  channel: Channel
}

type PostBoost implements Post {
  id: String!
  channelID: String!
  parentID: String
  authorID: String!
  createdAt: Time!
  updatedAt: Time!
  children: [Post]
  payments: [Payment!]
  paymentsTotal(currencyCode: String!): Float!
  currencyCode: String
  goalAmount: Float
  title: String!
  dateEnd: Time!
  why: String
  what: String
  about: String
  items: [PostBoostItem!]
  channel: Channel
}

type PostBoostItem {
  item: String!
  cost: Float!
}

type PostComment implements Post {
  id: String!
  channelID: String!
  parentID: String
  authorID: String!
  createdAt: Time!
  updatedAt: Time!
  children: [Post]
  payments: [Payment!]
  paymentsTotal(currencyCode: String!): Float!
  text: String!
  channel: Channel
}

type PostExternalLink implements Post {
  id: String!
  channelID: String!
  parentID: String
  authorID: String!
  createdAt: Time!
  updatedAt: Time!
  children: [Post]
  payments: [Payment!]
  paymentsTotal(currencyCode: String!): Float!
  url: String
  channel: Channel
}

type PostSearchResult {
  posts: [Post!]
  beforeCursor: String
  afterCursor: String
}

# input objects
input PostSearchInput {
  postType: String
  channelID: String
  authorID: String
  createdAfter: Time
  afterCursor: String
  beforeCursor: String
  limit: Int
  order: String
}

input PostCreateBoostInput {
  channelID: String!
  title: String!
  dateEnd: Time!
  goalAmount: Float!
  currencyCode: String!
  why: String!
  what: String!
  about: String!
  items: [PostCreateBoostItemInput!]
}

input PostCreateBoostItemInput {
  item: String
  cost: Float
}

input PostCreateExternalLinkInput {
  url: String!
}

input PostCreateCommentInput {
  text: String!
}

# Payment types
interface Payment {
  status: String
  reaction: String
  comment: String
  currencyCode: String
  exchangeRate: Float!
  amount: Float!
  createdAt: Time!
  updatedAt: Time!
  usdEquivalent: Float!
}

type PaymentStripe implements Payment {
  status: String
  reaction: String
  comment: String
  currencyCode: String
  exchangeRate: Float!
  amount: Float!
  createdAt: Time!
  updatedAt: Time!
  usdEquivalent: Float!
}

type PaymentEther implements Payment {
  status: String
  reaction: String
  comment: String
  currencyCode: String
  exchangeRate: Float!
  amount: Float!
  createdAt: Time!
  updatedAt: Time!
  transactionID: String!
  usdEquivalent: Float!
  fromAddress: String!
}

type PaymentToken implements Payment {
  status: String
  reaction: String
  comment: String
  currencyCode: String
  exchangeRate: Float!
  amount: Float!
  createdAt: Time!
  updatedAt: Time!
  transactionID: String!
  usdEquivalent: Float!
}

# Payment inputs
input PaymentsCreateStripePaymentInput {
  reaction: String
  comment: String
  currencyCode: String!
  amount: Float!
  paymentToken: String!
  emailAddress: String
}

# Payment inputs
input PaymentsCreateEtherPaymentInput {
  reaction: String
  comment: String
  transactionID: String!
  emailAddress: String
  paymentAddress: String!
  fromAddress: String!
  amount: Float!
  usdAmount: String!
}

# Payment inputs
input PaymentsCreateTokenPaymentInput {
  reaction: String
  comment: String
  transactionID: String!
  tokenAddress: String!
  emailAddress: String
}

## User object schemas

# A type that reflects values in users.User
type User {
  uid: String
  email: String
  ethAddress: String
  quizPayload: RawObject
  quizStatus: String
  civilianWhitelistTxID: String
  nrStep: Int
  nrFurthestStep: Int
  nrLastSeen: Int
  channels: [ChannelMember]
}

input UserSignatureInput {
  message: String!
  messageHash: String!
  signature: String!
  signer: String!
  r: String!
  s: String!
  v: String!
}

input UserUpdateInput {
  quizPayload: RawObject
  quizStatus: String
  nrStep: Int
  nrFurthestStep: Int
  nrLastSeen: Int
}

input NrsignupStepsInput {
  step: Int
  furthestStep: Int
  lastSeen: Int
}

type Newsroom {
  newsroomDeployTx: String
  contractAddress: String
  multisigAddress: String
  name: String
  charter: CharterContent
}

type NrsignupNewsroom {
  onboardedTs: Int
  charter: CharterContent
  charterLastUpdated: Int
  grantRequested: Boolean
  grantApproved: Boolean
  newsroomDeployTx: String
  newsroomAddress: String
  newsroomName: String
  tcrApplyTx: String
}

input CharterInput {
  name: String
  logoUrl: String
  newsroomUrl: String
  tagline: String
  roster: [RosterMemberInput]
  signatures: [ConstitutionSignatureInput]
  mission: CharterMissionInput
  socialUrls: CharterSocialUrlsInput
}

type CharterContent {
  name: String
  logoUrl: String
  newsroomUrl: String
  tagline: String
  roster: [RosterMember]
  signatures: [ConstitutionSignature]
  mission: CharterMission
  socialUrls: CharterSocialUrls
}

input RosterMemberInput {
  name: String
  role: String
  bio: String
  ethAddress: String
  socialUrls: CharterSocialUrlsInput
  avatarUrl: String
  signature: String
}

type RosterMember {
  name: String
  role: String
  bio: String
  ethAddress: String
  socialUrls: CharterSocialUrls
  avatarUrl: String
  signature: String
}

input CharterSocialUrlsInput {
  twitter: String
  facebook: String
  instagram: String
  linkedIn: String
  youTube: String
  email: String
}

type CharterSocialUrls {
  twitter: String
  facebook: String
  instagram: String
  linkedIn: String
  youTube: String
  email: String
}

input ConstitutionSignatureInput {
  signer: String
  signature: String
  message: String
}

type ConstitutionSignature {
  signer: String
  signature: String
  message: String
}

input CharterMissionInput {
  purpose: String
  structure: String
  revenue: String
  encumbrances: String
  miscellaneous: String
}

type CharterMission {
  purpose: String
  structure: String
  revenue: String
  encumbrances: String
  miscellaneous: String
}

## JSONb Store object schemas

type JsonField {
  key: String!
  value: JsonFieldValue!
}

input JsonbInput {
  id: String!
  jsonStr: String!
}

type Jsonb {
  id: String!
  hash: String!
  createdDate: Time!
  lastUpdatedDate: Time!
  rawJson: String!
  json: [JsonField!]!
}

## Common object schemas

input DateRange {
  gt: Int
  lt: Int
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
}

## Scalars

scalar ArticlePayloadValue
scalar JsonFieldValue
scalar RawObject
scalar Time
