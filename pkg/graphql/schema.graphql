schema {
  query: Query
}

# NOTE(PN): All date fields are ints in seconds from epoch

# The query type, represents all of the entry points into our object graph
type Query {
  # TCR / Crawler Queries (Legacy naming)
  # TODO(PN): Temporary keep these until migrated over to new naming
  # Just calls the properly named versions
  articles(
    addr: String
    first: Int
    after: String
    lowercaseAddr: Boolean = True
  ): [ContentRevision!]!
  challenge(id: Int!, lowercaseAddr: Boolean = True): Challenge
  governanceEvents(
    addr: String
    after: String
    creationDate: DateRange
    first: Int
    lowercaseAddr: Boolean = True
  ): [GovernanceEvent!]!
  governanceEventsTxHash(
    txHash: String!
    lowercaseAddr: Boolean = True
  ): [GovernanceEvent!]!
  listing(addr: String!, lowercaseAddr: Boolean = True): Listing
  listings(
    first: Int
    after: String
    whitelistedOnly: Boolean
    rejectedOnly: Boolean
    activeChallenge: Boolean
    currentApplication: Boolean
    lowercaseAddr: Boolean = True
    sortBy: ListingSort
    sortDesc: Boolean = False
  ): [Listing!]!

  # TCR Queries
  tcrChallenge(id: Int!, lowercaseAddr: Boolean = True): Challenge
  tcrGovernanceEvents(
    addr: String
    after: String
    creationDate: DateRange
    first: Int
    lowercaseAddr: Boolean = True
  ): GovernanceEventResultCursor
  tcrGovernanceEventsTxHash(
    txHash: String!
    lowercaseAddr: Boolean = True
  ): [GovernanceEvent!]!
  tcrListing(addr: String!, lowercaseAddr: Boolean = True): Listing
  tcrListings(
    first: Int
    after: String
    whitelistedOnly: Boolean
    rejectedOnly: Boolean
    activeChallenge: Boolean
    currentApplication: Boolean
    lowercaseAddr: Boolean = True
    sortBy: ListingSort
    sortDesc: Boolean = False
  ): ListingResultCursor

  # Newsroom Queries
  newsroomArticles(
    addr: String
    first: Int
    after: String
    lowercaseAddr: Boolean = True
  ): [ContentRevision!]!
  nrsignupNewsroom: NrsignupNewsroom

  # User Queries
  currentUser: User

  # Storefront
  storefrontEthPrice: Float
  storefrontCvlPrice: Float
  storefrontCvlQuoteUsd(usdToSpend: Float!): Float
  storefrontCvlQuoteTokens(tokensToBuy: Float!): Float

  # JSONb Store Query
  jsonb(id: String): Jsonb
}

type Mutation {
  # Auth Mutations
  authSignupEth(input: UserSignatureInput!): AuthLoginResponse
  authSignupEmailSend(
    emailAddress: String!
    addToMailing: Boolean = False
  ): String
  authSignupEmailSendForApplication(
    emailAddress: String!
    application: AuthApplicationEnum!
    addToMailing: Boolean = False
  ): String
  authSignupEmailConfirm(signupJWT: String!): AuthLoginResponse
  authLoginEth(input: UserSignatureInput!): AuthLoginResponse
  authLoginEmailSend(
    emailAddress: String!
    addToMailing: Boolean = False
  ): String
  authLoginEmailSendForApplication(
    emailAddress: String!
    application: AuthApplicationEnum!
    addToMailing: Boolean = False
  ): String
  authLoginEmailConfirm(loginJWT: String!): AuthLoginResponse
  authRefresh(token: String!): AuthLoginResponse

  # JSONb Store Mutations
  jsonbSave(input: JsonbInput!): Jsonb!

  # Newsroom Signup Mutations
  nrsignupSendWelcomeEmail: String!
  nrsignupSaveCharter(charterData: CharterInput!): String!
  nrsignupRequestGrant(requested: Boolean!): String!
  nrsignupApproveGrant(approved: Boolean!, newsroomOwnerUID: String!): String!
  nrsignupSaveTxHash(txHash: String!): String!
  nrsignupSaveAddress(address: String!): String!
  nrsignupPollNewsroomDeploy(txHash: String!): String!
  nrsignupPollTcrApplication(txHash: String!): String!
  nrsignupUpdateSteps(input: NrsignupStepsInput!): String!

  # Storefront Mutations
  storefrontAirswapTxHash(txHash: String!): String!
  storefrontAirswapCancelled: String!

  # User Mutations
  userSetEthAddress(input: UserSignatureInput!): String
  userUpdate(uid: String, input: UserUpdateInput): User
}

# Enum of valid values for application types for auth
enum AuthApplicationEnum {
  DEFAULT
  NEWSROOM
  STOREFRONT
}

## Auth object schemas
type AuthLoginResponse {
  token: String
  refreshToken: String
  uid: String
}

## TCR object schemas

# A type that reflects values in model.Appeal
type Appeal {
  requester: String!
  appealFeePaid: String!
  appealPhaseExpiry: Int!
  appealGranted: Boolean!
  appealOpenToChallengeExpiry: Int!
  statement: String!
  appealChallengeID: Int!
  appealChallenge: Challenge
  appealGrantedStatementURI: String!
}

# A type that reflects block data in model.BlockData
type BlockData {
  blockNumber: Int!
  txHash: String!
  txIndex: Int!
  blockHash: String!
  index: Int!
}

# A type that reflects values in model.Challenge
type Challenge {
  challengeID: Int!
  listingAddress: String!
  statement: String!
  rewardPool: String!
  challenger: String!
  resolved: Boolean!
  stake: String!
  totalTokens: String!
  poll: Poll
  requestAppealExpiry: Int!
  appeal: Appeal
  lastUpdatedDateTs: Int!
}

# A type that represents a Charter
type Charter {
  uri: String!
  contentID: Int!
  revisionID: Int!
  signature: String!
  author: String!
  contentHash: String!
  timestamp: Int!
}

# A type that reflects values in model.GovernanceEvent
type GovernanceEvent {
  listingAddress: String!
  metadata: [Metadata!]!
  governanceEventType: String!
  creationDate: Int!
  lastUpdatedDate: Int!
  eventHash: String!
  blockData: BlockData!
  listing: Listing!
}

# A type that represents an edge value in a GovernanceEvent
type GovernanceEventEdge {
  cursor: String!
  node: GovernanceEvent!
}

# A type that represents return values from GovernanceEvents
type GovernanceEventResultCursor {
  edges: [GovernanceEventEdge]!
  pageInfo: PageInfo!
}

# A type that reflects values in model.Listing
type Listing {
  name: String!
  contractAddress: String!
  whitelisted: Boolean!
  lastGovState: String!
  url: String!
  charter: Charter
  ownerAddresses: [String!]!
  owner: String!
  contributorAddresses: [String!]!
  createdDate: Int!
  applicationDate: Int
  approvalDate: Int
  lastUpdatedDate: Int!
  appExpiry: Int!
  unstakedDeposit: String!
  challengeID: Int!
  challenge: Challenge
  prevChallenge: Challenge
}

# A type that represents a edge value in a Listing
type ListingEdge {
  cursor: String!
  node: Listing!
}

# A type that represents return values from Listings
type ListingResultCursor {
  edges: [ListingEdge]!
  pageInfo: PageInfo!
}

# Enum of valid sort values for Listings
enum ListingSort {
  DEFAULT
  NAME
  CREATED
  APPLIED
  WHITELISTED
}

# A type that reflects values in model.Metadata
type Metadata {
  key: String!
  value: String!
}

# A type that reflects values in model.Poll
type Poll {
  commitEndDate: Int!
  revealEndDate: Int!
  voteQuorum: Int!
  votesFor: String!
  votesAgainst: String!
}

## Newsroom object schemas

# A type that reflects values in model.ArticlePayload
type ArticlePayload {
  key: String!
  value: ArticlePayloadValue!
}

# A type that reflects values in model.ContentRevision
type ContentRevision {
  listingAddress: String!
  payload: [ArticlePayload!]!
  payloadHash: String!
  editorAddress: String!
  contractContentId: Int!
  contractRevisionId: Int!
  revisionUri: String!
  revisionDate: Int!
}

## User object schemas

# A type that reflects values in users.User
type User {
  uid: String
  email: String
  ethAddress: String
  quizPayload: RawObject
  quizStatus: String
  civilianWhitelistTxID: String
  nrStep: Int
  nrFurthestStep: Int
  nrLastSeen: Int
}

input UserSignatureInput {
  message: String!
  messageHash: String!
  signature: String!
  signer: String!
  r: String!
  s: String!
  v: String!
}

input UserUpdateInput {
  quizPayload: RawObject
  quizStatus: String
  nrStep: Int
  nrFurthestStep: Int
  nrLastSeen: Int
}

input NrsignupStepsInput {
  step: Int
  furthestStep: Int
  lastSeen: Int
}

type NrsignupNewsroom {
  onboardedTs: Int
  charter: CharterContent
  charterLastUpdated: Int
  grantRequested: Boolean
  grantApproved: Boolean
  newsroomDeployTx: String
  newsroomAddress: String
  newsroomName: String
  tcrApplyTx: String
}

input CharterInput {
  name: String
  logoUrl: String
  newsroomUrl: String
  tagline: String
  roster: [RosterMemberInput]
  signatures: [ConstitutionSignatureInput]
  mission: CharterMissionInput
  socialUrls: CharterSocialUrlsInput
}

type CharterContent {
  name: String
  logoUrl: String
  newsroomUrl: String
  tagline: String
  roster: [RosterMember]
  signatures: [ConstitutionSignature]
  mission: CharterMission
  socialUrls: CharterSocialUrls
}

input RosterMemberInput {
  name: String
  role: String
  bio: String
  ethAddress: String
  socialUrls: CharterSocialUrlsInput
  avatarUrl: String
  signature: String
}

type RosterMember {
  name: String
  role: String
  bio: String
  ethAddress: String
  socialUrls: CharterSocialUrls
  avatarUrl: String
  signature: String
}

input CharterSocialUrlsInput {
  twitter: String
  facebook: String
  instagram: String
  linkedIn: String
  youTube: String
  email: String
}

type CharterSocialUrls {
  twitter: String
  facebook: String
  instagram: String
  linkedIn: String
  youTube: String
  email: String
}

input ConstitutionSignatureInput {
  signer: String
  signature: String
  message: String
}

type ConstitutionSignature {
  signer: String
  signature: String
  message: String
}

input CharterMissionInput {
  purpose: String
  structure: String
  revenue: String
  encumbrances: String
  miscellaneous: String
}

type CharterMission {
  purpose: String
  structure: String
  revenue: String
  encumbrances: String
  miscellaneous: String
}

## JSONb Store object schemas

type JsonField {
  key: String!
  value: JsonFieldValue!
}

input JsonbInput {
  id: String!
  jsonStr: String!
}

type Jsonb {
  id: String!
  hash: String!
  createdDate: Time!
  lastUpdatedDate: Time!
  rawJson: String!
  json: [JsonField!]!
}

## Common object schemas

input DateRange {
  gt: Int
  lt: Int
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
}

## Scalars

scalar ArticlePayloadValue
scalar JsonFieldValue
scalar RawObject
scalar Time
