schema {
  query: Query
}

# NOTE(PN): All date fields are ints in seconds from epoch

# The query type, represents all of the entry points into our object graph
type Query {

  # TCR / Crawler Queries (Legacy naming)
  # TODO(PN): Temporary keep these until migrated over to new naming
  # Just calls the properly named versions
  articles(addr: String, first: Int, after: String): [ContentRevision!]!
  challenge(id: Int!): Challenge
  governanceEvents(
    addr: String
    after: String
    creationDate: DateRange
    first: Int
  ): [GovernanceEvent!]!
  governanceEventsTxHash(txHash: String!): [GovernanceEvent!]!
  listing(addr: String!): Listing
  listings(
    first: Int,
    after: String,
    whitelistedOnly: Boolean,
    rejectedOnly: Boolean,
    activeChallenge: Boolean,
    currentApplication: Boolean,
  ): [Listing!]!

  # TCR Queries
  tcrChallenge(id: Int!): Challenge
  tcrGovernanceEvents(
    addr: String
    after: String
    creationDate: DateRange
    first: Int
  ): [GovernanceEvent!]!
  tcrGovernanceEventsTxHash(txHash: String!): [GovernanceEvent!]!
  tcrListing(addr: String!): Listing
  tcrListings(
    first: Int,
    after: String,
    whitelistedOnly: Boolean,
    rejectedOnly: Boolean,
    activeChallenge: Boolean,
    currentApplication: Boolean,
  ): ListingResultCursor

  # Newsroom Queries
  newsroomArticles(addr: String, first: Int, after: String): [ContentRevision!]!

  # User Queries
  currentUser: User

}

type Mutation {
  # KYC Mutations
  kycCreateApplicant(applicant: KycCreateApplicantInput!): String
  kycCreateCheck(applicantID: String!, facialVariant: String): String
  kycGenerateSdkToken(applicantID: String!): String

  # User Mutations
  userSetEthAddress(input: UserSetEthAddressInput!): String
  userUpdate(uid: String, input: UserUpdateInput): User
}


## TCR object schemas

# A type that reflects values in model.Appeal
type Appeal {
  requester: String!
  appealFeePaid: String!
  appealPhaseExpiry: Int!
  appealGranted: Boolean!
  appealOpenToChallengeExpiry: Int!
  statement: String!
  appealChallengeID: Int!
  appealChallenge: Challenge
}

# A type that reflects block data in model.BlockData
type BlockData {
  blockNumber: Int!
  txHash: String!
  txIndex: Int!
  blockHash: String!
  index: Int!
}

# A type that reflects values in model.Challenge
type Challenge {
  challengeID: Int!
  listingAddress: String!
  statement: String!
  rewardPool: String!
  challenger: String!
  resolved: Boolean!
  stake: String!
  totalTokens: String!
  poll: Poll
  requestAppealExpiry: Int!
  appeal: Appeal
  lastUpdatedDateTs: Int!
}

type Charter {
  uri: String!
  contentID: Int!
  revisionID: Int!
  signature: String!
  author: String!
  contentHash: String!
  timestamp: Int!
}

# A type that reflects values in model.GovernanceEvent
type GovernanceEvent {
  listingAddress: String!
  senderAddress: String!
  metadata: [Metadata!]!
  governanceEventType: String!
  creationDate: Int!
  lastUpdatedDate: Int!
  eventHash: String!
  blockData: BlockData!
  listing: Listing!
}

type ListingResultCursor {
  edges: [ListingEdge]!
  pageInfo: PageInfo!
}

type ListingEdge {
  cursor: String!
  node: Listing!
}

# A type that reflects values in model.Listing
type Listing {
  name: String!
  contractAddress: String!
  whitelisted: Boolean!
  lastGovState: String!
  url: String!
  charter: Charter
  ownerAddresses: [String!]!
  owner: String!
  contributorAddresses: [String!]!
  createdDate: Int!
  applicationDate: Int
  approvalDate: Int
  lastUpdatedDate: Int!
  appExpiry: Int!
  unstakedDeposit: String!
  challengeID: Int!
  challenge: Challenge
  prevChallenge: Challenge
}

# A type that reflects values in model.Metadata
type Metadata {
  key: String!
  value: String!
}

# A type that reflects values in model.Poll
type Poll {
  commitEndDate: Int!
  revealEndDate: Int!
  voteQuorum: Int!
  votesFor: String!
  votesAgainst: String!
}


## Newsroom object schemas

# A type that reflects values in model.ArticlePayload
type ArticlePayload {
  key: String!
  value: ArticlePayloadValue!
}

# A type that reflects values in model.ContentRevision
type ContentRevision {
  listingAddress: String!
  payload: [ArticlePayload!]!
  payloadHash: String!
  editorAddress: String!
  contractContentId: Int!
  contractRevisionId: Int!
  revisionUri: String!
  revisionDate: Int!
}


## KYC object schemas

# A type that reflects values in onfido.CreateApplicantRequest
input KycCreateApplicantInput {
  firstName: String!
  lastName: String!
  email: String
  middleName: String
  profession: String
  nationality: String
  countryOfResidence: String
  dateOfBirth: String
  buildingNumber: String
  street: String
  aptNumber: String
  city: String
  state: String
  zipcode: String
}


## User object schemas

# A type that reflects values in invoicing.PostgresInvoice
type Invoice {
  hash: String
  email: String
  phone: String
  name: String
  amount: Float
  invoiceID: String
  invoiceNum: String
  invoiceStatus: String
  checkID: String
  checkStatus: String
  stopPoll: Boolean
  isCheckbook: Boolean
  isThirdParty: Boolean
  referralCode: String
  referredBy: String
  emailState: Int
}

# A type that reflects values in users.User
type User {
  uid: String
  email: String
  ethAddress: String
  onfidoApplicantId: String
  onfidoCheckID: String
  kycStatus: String
  quizPayload: RawObject
  quizStatus: String
  # dateCreated: Int
  # dateUpdated: Int
  invoices: [Invoice]
  isTokenFoundryRegistered: Boolean
}

input UserSetEthAddressInput {
  message: String!
  messageHash: String!
  signature: String!
  signer: String!
  r: String!
  s: String!
  v: String!
}

input UserUpdateInput {
  onfidoApplicantID: String
  kycStatus: String
  quizPayload: RawObject
  quizStatus: String
}

## Common object schemas

input DateRange {
  gt: Int
  lt: Int
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
}


## Scalars

scalar ArticlePayloadValue
scalar RawObject
